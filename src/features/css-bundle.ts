import { Buffer } from 'node:buffer'
import { mkdir, readFile, writeFile } from 'node:fs/promises'
import path from 'node:path'
import { importWithError } from '../utils/general.ts'
import { esbuildTargetToLightningCSS } from '../utils/lightningcss.ts'
import type { ResolvedConfig } from '../config/index.ts'
import type { RolldownChunk } from '../utils/chunks.ts'

export interface CssBundleResult {
  chunks: RolldownChunk[]
}

export interface PreparedCssEntry {
  name: string
  code: Buffer
  outputName: string
}

/**
 * Prepare CSS entries using LightningCSS transform (without writing to disk).
 * This is the first step - transform CSS content but don't write files yet.
 *
 * @param config - Resolved tsdown config
 * @param cssEntries - CSS entry files to build
 * @returns Prepared CSS entries ready to be merged and written
 */
export async function prepareCssEntries(
  config: ResolvedConfig,
  cssEntries: Record<string, string>,
): Promise<PreparedCssEntry[]> {
  const { minify, target, cwd } = config
  const prepared: PreparedCssEntry[] = []

  // Dynamic import lightningcss using importWithError for proper error handling
  const lightningcss =
    await importWithError<typeof import('lightningcss')>('lightningcss')

  // Convert esbuild target format to lightningcss targets
  const targets = target ? esbuildTargetToLightningCSS(target) : undefined

  for (const [name, file] of Object.entries(cssEntries)) {
    const absolutePath = path.isAbsolute(file) ? file : path.resolve(cwd, file)

    // Read CSS file content
    const cssContent = await readFile(absolutePath)

    // Use lightningcss transform (not bundle) to process CSS
    // This preserves @import statements instead of inlining them
    const result = lightningcss.transform({
      filename: absolutePath,
      code: cssContent,
      minify: !!minify,
      targets,
    })

    prepared.push({
      name,
      code: Buffer.from(result.code),
      outputName: `${name}.css`,
    })
  }

  return prepared
}

/**
 * Write prepared CSS entries to disk, merging with existing CSS chunks if needed.
 * This is the second step - merge with Rolldown-generated CSS and write files.
 *
 * @param config - Resolved tsdown config
 * @param preparedEntries - CSS entries prepared by prepareCssEntries
 * @param existingCssChunks - CSS chunks already generated by Rolldown (e.g., from Vue components)
 * @returns CSS chunks for reporting
 */
export async function writeCssEntries(
  config: ResolvedConfig,
  preparedEntries: PreparedCssEntry[],
  existingCssChunks?: RolldownChunk[],
): Promise<CssBundleResult> {
  const { outDir } = config
  const chunks: RolldownChunk[] = []

  // Ensure output directory exists
  await mkdir(outDir, { recursive: true })

  // Build a map of existing CSS chunks by their base name (without extension)
  const existingCssMap = new Map<string, RolldownChunk>()
  if (existingCssChunks) {
    for (const chunk of existingCssChunks) {
      if (chunk.type === 'asset' && /\.css$/i.test(chunk.fileName)) {
        const baseName = chunk.fileName.replace(/\.css$/i, '')
        existingCssMap.set(baseName, chunk)
      }
    }
  }

  for (const { name, code, outputName } of preparedEntries) {
    let finalCode = code

    // Check if there's an existing CSS chunk with the same name (e.g., from Vue components)
    // If so, merge the content
    const existingChunk = existingCssMap.get(name)
    if (existingChunk && existingChunk.type === 'asset') {
      const existingContent =
        typeof existingChunk.source === 'string'
          ? existingChunk.source
          : new TextDecoder('utf-8').decode(existingChunk.source)

      // Merge: CSS entry content first, then existing content (from Vue components, etc.)
      finalCode = Buffer.concat([
        code,
        Buffer.from('\n'),
        Buffer.from(existingContent),
      ])
    }

    const outputPath = path.join(outDir, outputName)

    // Write to file
    await writeFile(outputPath, finalCode)

    // Record chunk info for reporting
    chunks.push({
      type: 'asset',
      fileName: outputName,
      name,
      source: finalCode,
    } as unknown as RolldownChunk)
  }

  return { chunks }
}

/**
 * Build CSS entries using LightningCSS transform.
 * This bypasses Rolldown to avoid generating empty JS files for CSS-only entries.
 *
 * We use `transform` instead of `bundleAsync` to avoid inlining @import statements,
 * preserving the original behavior where each CSS file is output separately.
 *
 * @param config - Resolved tsdown config
 * @param cssEntries - CSS entry files to build
 * @param existingCssChunks - CSS chunks already generated by Rolldown (e.g., from Vue components)
 *                            These will be merged with CSS entry content if they have the same name.
 */
export async function buildCssEntries(
  config: ResolvedConfig,
  cssEntries: Record<string, string>,
  existingCssChunks?: RolldownChunk[],
): Promise<CssBundleResult> {
  const prepared = await prepareCssEntries(config, cssEntries)
  return writeCssEntries(config, prepared, existingCssChunks)
}
